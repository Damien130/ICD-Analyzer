import deeptrack as dt
import numpy as np
import skimage.color
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.figure import Figure
from tkinter import *
from PIL import Image
import skimage.io
import csv
import concurrent.futures
import os

os.environ['TF_ENABLE_AUTO_MIXED_PRECISION'] = '1'

#TkAgg (instead of Qt5Agg) is needed to display the plot in the GUI
matplotlib.use("TkAgg") 
t, x, y, w = (1, 635, 178, 15) # (frame, x, y, width)
training_image = dt.LoadImage(f"/mnt/h/TRAINING0620.tif")()._value / 256
crop = training_image[y:y+w, x:x+w] # crop the image

model = dt.models.LodeSTAR(input_shape=(None, None, 3)) # create the model

train_set = (
    dt.Value(crop)
    >> dt.Add(lambda: np.random.randn() * 0.1)
    >> dt.Gaussian(sigma=lambda: np.random.uniform(0, 0.2))
    >> dt.Multiply(lambda: np.random.uniform(0.6, 1.2))
)

# train the model
model.fit(
    train_set,
    epochs=50,
    batch_size=8,
)

# alpha is the probability of a pixel being a cell
alpha = 0.2
# cutoff is the threshold for a pixel to be considered a cell
cutoff = 0.99

# read in the tif file, wildcard * is used to read in 
# all tif files in the folder
tif_file = '/mnt/h/20230620/LTB4-500nM-2.5uL-1_*.tif' 
multi_tif = skimage.io.MultiImage(tif_file)
length = len(multi_tif)

frame_counts = {}

# process_image is the function that will be run in parallel
def process_image(i):
    # create a csv file for each image
    csv_filename = f'/mnt/h/20230620/data/nodes20230620_{i}.csv'
    with open (csv_filename, 'a', newline='') as csvfile:
        writer = csv.writer(csvfile, delimiter=',')
        writer.writerow(['particle number', 'x', 'y', 'frame','picture'])
    
    # read in the image
    images = multi_tif[i]

    fNumber = 0 # frame number
    frame_cell_counts = [] # number of cells in each frame
    passed_cells = set() # set of cells that have passed through the channel

    for frame in images:
        # crop the image
        image = frame[0:200, 155:1300]
        image = image / 256 # normalize the image
        # detect the cells
        # detections is a numpy array of shape (num_cells, 3)
        detections = model.predict_and_detect(image[np.newaxis], 
                                              alpha=alpha, 
                                              beta=1-alpha, 
                                              cutoff=cutoff, 
                                              mode="quantile")[0]
        num_rows, num_cols = detections.shape

        #if fNumber == 0:
            #outputFig = plt.figure(figsize=(18,2.5))
            #ax = outputFig.add_subplot(111)
            #ax.imshow(image)
            #ax.axis("off")
            #ax.scatter(detections[:, 1], detections[:, 0], s=20, 
            #           linewidths=1, marker="x", color="red")
            #outputFig.savefig(f'/mnt/h/20230620/processed/LTB4-500nM-2.5uL-1_{i}.png')
            #plt.close(outputFig)
        
        # update the set of cells that have passed through the channel
        passed_cells.update(detections[:, 0])

        # write the data to the csv file
        with open(csv_filename, 'a', newline='') as csvfile:
            writer = csv.writer(csvfile, delimiter=',')
            for j in range(num_rows):
                if detections[j, 0] in passed_cells:
                    writer.writerow([j, detections[j, 1], 
                                     detections[j, 0], fNumber, i])
            del detections
        fNumber += 1
        
        # update the number of cells in each frame
        frame_cell_counts.append(len(passed_cells))

    # update the dictionary of frame counts
    frame_counts[i] = frame_cell_counts

# run the process_image function in parallel
max_concurrent_tasks = 16
with concurrent.futures.ThreadPoolExecutor(max_workers=
                                           max_concurrent_tasks) as executor:
    executor.map(process_image, range(length))

# plot the cumulative cell counts
cumulative_counts = np.sum(list(frame_counts.values()), axis=0)

# plot the cumulative cell counts
plt.plot(cumulative_counts)
plt.xlabel("Frame")
plt.ylabel("Cumulative Cell Count")
plt.title("Cumulative Object Counting (Cells Passing Through Channel)")
plt.savefig('/mnt/h/20230620/data/cumulative_counts.png')

# write the cumulative cell counts to a csv file
with open('/mnt/h/20230620/data/cumulative_counts.csv', 
          'w', newline='') as csvfile:
    writer = csv.writer(csvfile, delimiter=',')
    writer.writerow(['frame', 'cumulative count'])
    for i in range(len(cumulative_counts)):
        writer.writerow([i, cumulative_counts[i]])